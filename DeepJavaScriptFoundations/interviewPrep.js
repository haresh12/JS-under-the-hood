/**
 *  ALL IMPORTENT JAVASCRIPT QUESTIONS
 *
 */

/***
 *   EXECUTION CONTEXT :  EVERYTHING IN JS HAPPENS INSIDE EXECUTION CONTEXT  ITS JUST LIKE CONTAINER 
 * 
 *    IT HAS TWO PART MEMORY CREATION AND CODE EXECUTION
 * 
 *    MEMORY CONTAINER : STORE ALL THE FUNCTIONS AND COMPONENT IN KEY VALUE PAIR 
 * 
 *    FOR VARIABLE THE VALUE WILL BE UNDEFIEND AND FOR FUNCTION IT STORES ENITER CODE OF THE FUNCTION
 * 
 *    ALSO JS IN SNCRONIZED SINGLE TRHREADED LANGUAGE SO AT THE TIME OF CODE EXECUTION CODE GET EXECUTED ONE LINE AT A TIME AND SOME SPECIFIC ORDER 
 *    AND THAT ORDER IS TOP TO BOTTOM
 * 
 *    ALSO THIS CODE COMPONENT IS ALSO KNOWN AS THREAD OF EXECUTION => SEE AT THE END ITS RUNNING CODE LINE BY LIN E NOTHING NEW IS HAPPENING THERE
 * 
 *    Synchronous:- In a specific synchronous order.
      Single-threaded:- One command at a time.
 *  
 * 
 */

/***
 *     How JS is executed & Call Stack
 *
 *     AS SOON AS WE RUN ANY JAVASCRIPT PROGRAM THE FIRST THING WILL HAPPEN IS GLOBAL EXECUTION CONTEXT WILL BE CREATED
 *     NOW THAT GLOBAL EXECUTION CONTEXT WILL HAVE TWO PART LIKE MEMORY CREATION FACE AND CODE EXECTUTION FACE NOW
 *     IN FIRST PHASE JS WILL TRY TO ASSIGN MEMORY TO EACH AND EVERY VARIABLES AND FUNCTION
 *
 *     IN FIRST PHASE OF MEMORY CREATION  JS WILL ASSIGN UNDEFINED VALUE TO VARIABLES AND IN CASE OF FUNCTIONS IT WILL COPY ENTIRE FUNCTIONS CODE
 *
 *     NOT SECOND PART COMES INTO THE PICTURE WHICH IS CODE EXEUCTION PHASE IN THAT JS WILL TRY TO RUN CODE ONE LINE AT TIME FROM TOP TO BOTTOM
 *
 *    IF YOU SEE EVERYTHING IN SECOND PHASE IS SAME AS OTHER LANGUAGE SO HERE ONE THING WE NEED TO UNDERSTAND IS THAT IN JAVASCRIPT AT THE THE
 *    TIME OF CODE EXECUTION IF IT SEES THE NEW FUNCTIO THEN FOR THAT NEW EXECUTION CONTEXT WILL BE CRREATED AND SAME PROCESS WILL HAPPEN AGAIN
 *
 *    SO FIRST GLOBLE EXECUTION CONTEXT : GOOD SAME TO PART MEMORY CREATION AND CODE EXECUTION
 *
 *    FOR EACH FUNCTION JS WILL CREATE LOCAL EXECUTION CONTEXT I AM JUST USING WORD LOCAL FOR MY UNDERSTANDING ELSE WE CAN SIMPLY SAY GLOBAL EXECUTION CONTEXT
 *
 *    ONE MORE THING WE NEED TO UNDERSTAND THAT WHETHER ITS GLOBAL OR WHETHER ITS LOCAL BOTH EXECUTION CONTEXT WILL BEHAVE SAME WAY AND BOTH WILL HAVE SAME TWO
 *    FACES MAKE SENSE
 *
 *    SEE IF WE WILL TRY TO REMEBER EVERYTHING THEN THATS HARD BUT IF YOU UNDERSTAND THIS THINGS THIS ARE SIMPLE THING
 *
 *    AT THIS POINT OF TIME ONE QUEUSTION CAN COME INTO MIND THAT HOW THE HELL JS HANDLES ALL THIS THINGS LIKE GLOBAL EXECUTION CONTEXT , EXECUTION CONTEXT AND
 *    EVERYHING SO SIMPLE ANSWER FOR THAT IS ALSO CALL STACK :
 *
 *    FIRST GLOBLE EXEUCTION CONTEXT WILL BE PUTTED INTO CALL STACK AND THEN EACH AND EVERY FUNCTION SUPPOSE FUNCTION IS DONE WITH ITS EXECUTION PART THEN
 *    IT WILL BE REMOVED FROM CALLSTACK AND AT LAST GLOBAL EXECUTION CONTEXT WILL BE REMOVED FROM THE CALLSTACK
 */

/***
 *    SO TILL THIS POINTS WE LEARD FEW IMPORTENT WORD AS BELOW
 *
 *    SYNCRONIZED SINGLE THREADED LANGUAGE
 *    MEMORY CREATION PHASE
 *    CODE EXECUTION PHASE : ALSO KNOW AS THREAD OF EXECUTION
 *    CALL STACK
 *    EXECUTION CONTEXT
 *    GLOBAL EXECUTION CONTEXT
 */

/**
 *  Hoisting in JavaScript (variables & functions)
 *
 *  BEFORE WE TALK ABOUT HOISTING UNDERSTAND ONE THING THAT
 *
 *   console.log(a);
 *   var a = 10;
 *
 *  IF YOU WILL TRY TO RUN THIS KIND FO CODE IN ANY OTHER PROGRAMING LANGUAGE THEN IT WILL THROUGH AS ERROR LINE ANYTHING SO ALWAYS BE THANKFUL FRO JAVASCRIPT
 *
 *  BUT HARESH COULD YOU TELL US HOW JS DOES THAT WHATS THE MAGIC BEHIND THAT ?
 *
 *   IF YOU NEED AWNSER IN ONE WORD THAN ITS BECAUSE OF TWO PHASE OF JAVASCRIPT CODE EXECUTION 1. MEMORY CREATTION AND CODE EXECUTION
 *
 *   IN  JS MEMORY CREATION PHASE HAPPENS FIRST AND THEN ACTUALLY CODE EXECUTION HAPPENS NOW IN MEMORY CREATION PHASE JS ALREADY ASSING UNDEFINED VALUE FO A
 *   VARIABLE AND THIS WAY AT THE TIME OF CODE EXECUTION JS ALREADY KNOW THAT I HAVE ASSIGNED MEMEORY TO VARIABLE A IN PAST SO I AM SURE THAT IT WILL BE IN THE
 *   PROGRAM
 *
 *  AND MAKE SURE FOR ABOVE CODE OUTPUT WILL BE UNDEFINED BECAUSE THAT IS THE DEFAULT VALUE JAVASCRIPT GIVES VARIABLES AND WE ARE ASSIGNING ACTUAL VALUE AFTER CONSOLE
 *  LOG SO BEFORE THAT IT WILL BE ALWAYS UNDEFINED.
 *
 *  IN CASE OF FUNCTION PICTURE IS LITTLE DIFFERNT SEE IN CASE OF FUNCTION JS STORE ENTIRE FUNCTION CODE SO THERE IF YOU WILL SEE WE WILL GET THE EXECT OUTPUT
 *
 *  IN CASE OF FUNCTION WE DON'T NEED TO WORRY WHETHERE YOU CAN CALLING FUNCTION BEFORE DECLERING IT AND IN CASE OF VARIABLE YOUR APP WON'T GET CRASH
 *  BUT VALUE WILL BE UNDEFINED
 *
 *   sameDay()  // call before declertion no issue brother i will give you same output
 *   function sameDay(){
 *     console.log('BE HUMBLE BE NICE BUT NEVER LET GO')
 *   }
 *   sameDay() // calling after declerion no issue at all i will give you same output MAKE SURE YOU ALWAYS PREFER THIS ONE RATHER THEN ABOVE ONE
 *
 *  NOW HARESH I UNDERSTAND THIS BUT WHAT HAPPENS IN CASE OF ARROW FUNCION : GOOD QUESTION
 *
 *  In case of arrow function your program will be crashed if you try to run function before initalizing it and it make sense
 *
 *  SEE IN CASE OF ARROW FUNCTION AT THEN TIME OF MEMORY CREATION THE JS ASSIGN UNDEFIEND VALUE TO THE FUNCTION AND NOW IF YOU TRY TO INVOKE UNDEFINED THEN
 *  WHAT ELSE OUTPUT WILL YOU EXPECT.
 *
 *    doSomething();  // WHY ARE YOU CALLING ME BEFORE INITAILIZING ME
 *
 *   var doSomething =  () => {
 *    console.log("but i have nothing to do sir");
 *   }
 *
 *  TILL KNOW YOU MIGHT BE HAVE CONFUTION THAT WHY ITS BEHAVING DIFFERENT IN CASE OF NORMAL FUNCION AND IN CASE OF ARROW FUNCTION SEE REMEMBER SIMPLE THING
 *  THAT IN CASE OF ARROW FUNCTION  UNDEFINED VALUE IS GETTING ASSING TO THE VARIABLE IN CASE OF NORMAL FUNCTION ENTIRE CODE HASE BEEN COPIED.
 *
 *
 *  IN MOST OF THE INTERVIEWS THEY MAY ASK YOU WHATS THE DIFFERENT BETWEEN ARROW FUNCTION AND NORMAL FUNCTION SO SIMPLE ANSWER IS HOISTING AND OTHER MAJOR
 *  DIFFERNT IS HOW THIS KEYWORD BEHAVES BUT THAT WE WILL LEARN LATER
 *
 *
 *  HERE ONE MORE IMPORTENT THING TO LEARN THAT THERE IS HUGE DIFFERENCE BETWEEN UNDEFIEND AND NOT DEFINED
 *
 *   // PROGRAM 1 THIS WILL GIVE YOU UNDEFINED BECAUSE X IS IN THE MEMORY IT JUST NO VALUE HAS BEEN ASSGINED AT THE POINT OF CONSOLE.
 *    console.log(x)
 *    var x = 20;
 *
 *   /// PROGRAM 2 WE DON'T HAVE Y ANYWHERE SO IT WON'T EVEN RUN THE PROGRAM IT WILL GIVE SIMPLE ERROR THAT Y IS NOT-DEFINED
 *   console.log(y);
 *
 *   ONE YOU UNDERSTAND DIFFERENT BETWEEN UNDEFINED AND NOT DEFINED YOU UNDERSTAND LIFE
 */

/***
 *  HERE WE LEARNED FEW WORDS
 *
 *  HOISTING
 *  ARROW FUNCTION AND NORMAL FUNCTION
 *  UNDEFINED AND NOT DEFINED
 */

/**
 *   Functions and Variable Environments  : (THIS IS SIMPLE NOT MUCH TO EXPLAIN)
 *
 *   var x = 1;
 *   a();
 *   b();
 *
 *  function a() {
 *   var x = 10;
 *   console.log(x);
 *  }
 *
 *  function b() {
 *   var x = 10;
 *   console.log(x);
 *  }
 *
 *   console.log(x);
 *
 *   SEE ONLY THING TO LEARN HERE IS ABOUT HOW FUNCTIONS FINDS OUT FOR THE VARIABLES GIVEN THE EXAMPLE YOU SEE WE HAVE 3 DIFFERENT X VARIABLES ONE INSIDE
 *   A FUNCTION ONE INSIDE B FUNCTION AND ONE AT GLOBAL LEVEL
 *
 *  NOW SEE WHEN WE ARE RUNNING FUNCTION A() AT THAT TIME FUNCTION A WILL TRY TO FIND X INSIDE IT OWN EXECTION CONTEXT AND WE CAN SEE IT HAS VARIABLE A SO
 *  IT WILL SIMPLE PRINT IT
 *
 *  SAME GOES WITH FUNCTION B() IT ALSO HAVE VARIABLE X INSIDE ITS OWN EXECUTION CONTEXT SO GREAT AGAIN IT WILL USE FROM THERE
 *
 *  NOW ALSO AT GLOBAL SPACE IT HAS SAME THING WE HAVE X IN GLOBAL SPACE SO SIMPLE EVERYTHING IS FINE
 *
 *  IN SIMPLE WORD THERE IS NOT MUCH TO UNDERSTAND IN THIS PROGRAM BECAUSE WE HAVE X IN EACH AND EVERY EXECUTION CONTEXT THING ABOUT THE SEANRIO WHERE
 *  WE DON'T HAVE X IN A() FUNCTION OR IN B() FUNCTION IN THAT CASE WHAT WILL HAPPEN HOW THINGS WORK ALL THAT WE WILL LEARN IN NEXT TOPIC
 */

/**
 *     Shortest JS Program, window & this keyword
 *
 *     The shortest JS program is empty file.
 *     Because even then, JS engine does a lot of things.
 *     As always, even in this case, it creates the GEC which has memory space and the execution context.
 *
 *    SEE EVEN YOU DON'T HAVE SINGLE LINE OF CODE TO RUN JAVASCRIPT WILL STILL DO LOT OF THINGS IN BACKGROUND AND THOSE THINGS ARE LIKE
 *    CREATEING GLOBAL EXECUTION CONTEXT AND PROVIDING USE WINDOW OBJECT
 *
 *    NOW SEE THE WINDOW OBJECT HAS LOTS OF METHODS THAT WE USE BUT IN CASE OF BROWSER YOU WILL GET WINDOW OBJECT IN CASE OF NODE THAT WINDOW
 *    OBJECT WILL BE GLOBEL AND ONE MORE INTERSTING THING IS THAT IN GLOBAL EXECTION CONTEXT WINDOW ===  THIS ===  GLOBAL
 *
 *    ALSO UNDERTAND THAT ALL BELOW THINGS WILL GIVE SAME OUTPUT
 *
 *    function raho(){
 *     console.log("bolna")
 *   }
 *
 *   raho();
 *   this.raho():
 *   window.raho();
 *
 *  // ALL THREE ARE SAME AT GLOBAL LEVEL NO DIFFERNCE BETWEEN THEM
 *
 *  IF I HAVE TO TAKE ONE LEARING POINT FROM HERE THEN IT WOULD BE LIKE UNDERSTADING OF WINDOW OBJECT AND HOW WINDOW , GLOBAL OBJECT ARE AME WHEN WE
 *  COMPARE THEM AT GLOBAL LEVEL . AND ALSO WINDOW ====  THIS === GLOBAL JUST TAKE THIS ONE POINT THATS ENOUGH
 */

/**
 *  POINTS THAT WE LEARNED
 *  HOW FUNCTION AND VARIABLE BEHAVE WHEN THEY HAVE SAME NAME VARIABLES
 *  WINDOW OBJECT
 *  CREATION OF GEC EVEN WE RUN THE EMPTY FILE
 *  THIS (WILL GO DEEPER INTO THAT)
 *  DIFFERENT ENVIROMENT CAN HAVE DIFFERENT NAMES FOR GLOBAL OBJECT
 *  LAST BUT MI : THIS ==== WINDOW ==== GLOBAL
 */
